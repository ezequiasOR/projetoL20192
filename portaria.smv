-- Este arquivo descreve o funcionamento de um estacionamento que
-- possui apenas uma via para a entrada e saida de carros, cuja
-- portaria adminitra por meio de dois sinais, o momento em que a
-- passagem está apta para entrada ou para saída. A estrutura da
-- máquina de estados tem como base um semáforo utilizado em sistemas
-- operacionais para a gerencia de mémoria compartilhada.
-- A definicao das variaveis utilizadas na FSM encontra-se a seguir.

-- semaforoEntrada : flag booleana reprensentando o semaforo que habilita a entrada 
-- semaforoSaida : flag booleana reprensentando o semaforo que habilita a saída
---- Verde    = TRUE
---- Vermelho = FALSE

-- cancela1
-- cancela2
---- aberta  = TRUE
---- fechada = FALSE

-- critico : flag booleana que indica se a região critica (passagen) encontra-se ocupada
---- ocupada = TRUE
---- livre   = FALSE

-- sentido : o sentindo do fluxo da passagem é indicado pelas variaveis booleanas,
--           que são utilizadas no fluxo de controle das cancelas.
---- flag_entrando
---- flag_saindo

-- vagas: indica o número de carros estacionados na garagem

---------------------------------------------------------------

MODULE main

VAR
  semaforoEntrada : boolean;
  semaforoSaida : boolean;
  passagem : process portaria(semaforoEntrada, semaforoSaida);

ASSIGN
-- Ambos os semaforos iniciam como VERMELHO (fechados)
  init(semaforoEntrada) := FALSE;
  init(semaforoSaida) := FALSE;
  
-- Especificações sobre o valor de critico: Quando a região crítica estiver ocupada, a flag critica deve ser verdadeira.
INVARSPEC (passagem.estado = aguardando -> passagem.critico = FALSE);
INVARSPEC (passagem.estado = entrando -> passagem.critico = TRUE);
INVARSPEC (passagem.estado = saindo -> passagem.critico = TRUE);

-- Especificações sobre os valores dos semáforos: Quando ocupado, os semáforos devem ser complementares
INVARSPEC (semaforoEntrada = TRUE -> semaforoSaida = FALSE);
INVARSPEC (semaforoSaida = TRUE -> semaforoEntrada = FALSE);

-- Especificações sobre as flags de fluxo: Quando ocupado, as flags devem ser complementares
INVARSPEC (passagem.flag_entrando = TRUE -> passagem.flag_saindo = FALSE)
INVARSPEC (passagem.flag_saindo = TRUE -> passagem.flag_entrando = FALSE)

-- Especificações sobre o comportamento das cancelas: Cancelas nunca abrem simultaneamente
INVARSPEC (passagem.estado = c1_aberta -> passagem.cancela2 = FALSE)
INVARSPEC (passagem.estado = c2_aberta -> passagem.cancela1 = FALSE)

-- Especificação sobre os valores limites para vagas: Nunca menor que zero e maior que cem.
INVARSPEC (passagem.vagas >= 0 & passagem.vagas <= 30)

---------------------------------------------------------------

MODULE portaria(semaforoEntrada, semaforoSaida)
VAR
  estado : {aguardando, ocupado, entrando, saindo, c1_aberta, c1_fechada, c2_aberta, c2_fechada, livre};
  cancela1: boolean;
  cancela2: boolean;
  critico: boolean;
  flag_entrando: boolean;
  flag_saindo: boolean;
  vagas: 0 .. 100;

ASSIGN
  init(cancela1) := FALSE;
  init(cancela2) := FALSE;
  init(critico) := FALSE;
  init(flag_entrando) := FALSE;
  init(flag_saindo) := FALSE;
  init(vagas) := 0;

  init(estado) := aguardando;
  next(estado) := 
  case 

    -- Muda de estado de forma nao deterministica
    estado = aguardando : {aguardando, ocupado};
    estado = ocupado : {entrando, saindo};
    
    -- Fluxo de entrada
    (estado = entrando) & (semaforoEntrada=TRUE):c1_aberta;		-- tem que colocar que vagas tem que ser menor que 30 aqui?
    (estado = c1_aberta) & (cancela1=FALSE): c1_fechada;
    (estado = c1_fechada) & (cancela2=TRUE): c2_aberta;
    (estado = c2_aberta) & (cancela2=FALSE): c2_fechada;
    (estado = c2_fechada) & (flag_entrando=TRUE): livre;

    -- Fluxo de saida
    (estado = saindo) & (semaforoSaida=TRUE) & (vagas >= 1): c2_aberta;
    (estado = c2_aberta) & (cancela2=FALSE):  c2_fechada;
    (estado = c2_fechada) & (cancela1=TRUE):  c1_aberta;
    (estado = c1_aberta) & (cancela1=FALSE):  c1_fechada;
    (estado = c1_fechada) & (flag_saindo=TRUE): livre;
    
    -- Carro entrou ou saiu com sucesso
    (estado = livre): aguardando;

    TRUE : estado;
    esac;
  
  next(semaforoEntrada) := 
    case
      (estado = entrando) & (vagas < 30) : TRUE;
      estado = saindo : FALSE;
      estado = aguardando: FALSE;
      TRUE : semaforoEntrada;
    esac;

  next(semaforoSaida) := 
    case
      estado = entrando : FALSE;
      (estado = saindo) & (vagas > 0): TRUE;
      estado = aguardando: FALSE;
      TRUE : semaforoSaida;
    esac;

  next(cancela1) :=
    case
      estado = entrando: TRUE;
      estado = c1_aberta: FALSE;
      estado = c2_fechada: TRUE;
      estado = aguardando: FALSE;
      TRUE: cancela1;
    esac;

  next(cancela2) :=
    case
      estado = saindo: TRUE;
      estado = c1_fechada: TRUE;
      estado = c2_aberta: FALSE;
      estado = aguardando: FALSE;
      TRUE: cancela2;
    esac;

  next(critico) :=
    case
      estado = ocupado: TRUE;
      estado = livre: FALSE;
      TRUE : critico;
    esac;

  next(flag_entrando) :=
    case
      estado = entrando: TRUE;
      estado = saindo: FALSE;
      estado = aguardando: FALSE;
      TRUE: flag_entrando;
    esac;

  next(flag_saindo) :=
    case
      estado = entrando: FALSE;
      estado = saindo: TRUE;
      estado = aguardando: FALSE;
      TRUE: flag_saindo;
    esac;

  next(vagas) :=
  case
    (estado = livre) & (flag_entrando=TRUE) & (vagas < 30) : vagas + 1;
    (estado = livre) & (flag_saindo=TRUE) & (vagas > 0): vagas - 1;
    TRUE: vagas;
  esac;

FAIRNESS
  running
